计算1+2+...+100
#!/bin/bash
#sum1.sh

total=0;   
num=0;
while((num<=100));
do
        total=` expr $total + $num `   #expr在循环中用于增量计算,注意空格
        num=` expr $num + 1 `
done

echo "$total"


范例：有一组数据，存有某村所有家庭的人数和月总收入，找出人均月收入最高家庭
#!/bin/bash
# gettopfamily.sh

[ $# -lt 1 ] && echo "please input the income file" && exit -1
[ ! -f $1 ] && echo "$1 is not a file" && exit -1

income=$1
awk '{
        printf("%d %0.2f\n", $1, $3/$2);
}' $income | sort -k 2 -n -r


aaa 12 1 
aaa 12 2 
aaa 12 4 
aaa 15 1
aaa 15 2
bbb 12 1
bbb 12 2
最后我想得出的输出结果为
aaa  12  7
aaa  15  3
bbb  12  3

#!/usr/bin/awk -f	#表示以下语句的解释器为awk，-f 表示，awk脚本运行时需要跟一个文件名参数（awk一般就是用于文本处理的）。
NR == 1 { col1 = $1; col2 = $2; col3 = $3; }	#NR==1 行数为1 之后赋值 注意空格	
NR > 1 {        
	if($1 == col1 && $2 == col2)                
	col3+=$3;				# col3+$3=$3
else        
	{                   
	print(col1" "col2" "col3);               
	col1 = $1; col2 = $2; col3 = $3;        
	}   
}
END { print(col1" "col2" "col3); }


NR小例子
whwu@master:~/script> echo -e "A B C\nD E F\nG H I" | awk 'NR==1 {print $1}' # Number 0f Row（NR）
A


一个文件中如果有相同的行连续出现就只打印一次
whwu@master:~/script> cat error_strip.sh
#!/bin/awk -f

 #to call: error_strip.awk <filename>
 #strips out the ERROR* lines if there are more than one
 #ERROR* lines after each filed record.
 BEGIN{
     error_line=""                                       #定义变量error_line
 }
     #tell awk the whole is "ERROR *"
     {
         if ($0 == "ERROR*" && error_line == "ERROR*")   #如果整行是ERROR*，且error_line=ERROR*
            { next}					 #回到程序开头，忽略后面语句
        else
            { error_line = $0;                           #else error_line为整行信息
        print                                            #打印
        }
     }


 #!/bin/awk -f
 #error_strip.awk
 #to call: error_strip.awk <filename>
 #strips out the ERROR* lines if there are more than one
 #ERROR* lines after each filed record.
 BEGIN{
     error_line=""
 }
     #tell awk the whole is "ERROR *"
     {
         if ($0 == "ERROR*" && error_line == "ERROR*")
             next;
         error_line = $0;
         print
     }

whwu@master:~/script>cat error_strip.sh
INVALID LCSD 98GJ23
ERROR*
ERROR*
CAUTION LPSS ERROR ON ACC NO.
ERROR*
ERROR*
ERROR*
ERROR*
ERROR*
PASS FILED INVALID ON GHSI
ERROR*
CUTION LPSS ERROR ON ACC NO.
ERROR*
ERROR*

whwu@master:~/script> ./error_strip.sh error.txt
LID LCSD 98GJ23
ERROR*
CAUTION LPSS ERROR ON ACC NO.
ERROR*
PASS FILED INVALID ON GHSI
ERROR*
CUTION LPSS ERROR ON ACC NO.
ERROR*


#向AWK脚本传递参数
whwu@master:~/script> cat age.sh
#!/bin/awk -f
#age.sh
{
        if($5 < AGE )
                print $0
}
whwu@master:~/script> ./age.sh AGE=10 grade.txt
M.Tansley       05/99   48311   Green   8       40      44
J.Lulu          06/99   48317   green   9       24      26

awk 数组，awk数组是类似于一个键值对，既可以使用数字做下标，也可以使用字符串做下标
whwu@master:~/script> cat arraytest.sh
#!/bin/awk -f
#name:arraytest.sh
#prints out an array

BEGIN{
        record="123#456#789";
        split(record,myarray,"#")
}
END{
        for(i in myarray)
        {
                print myarray[i]
        }
}
whwu@master:~/script> ./arraytest.sh size.txt
123
456
789


grade_student.txt:
 
Yellow#Junior
Orange#Senior
Yellow#Junior
Purple#Junior
Brown-2#Junior
White#Senior
Orange#Senior
Red#Junior
Brown-2#Senior
Yellow#Senior
Red#Junior
Blue#Senior
Green#Senior
Purple#Junior
White#Junior

 #!/bin/awk -f
 #name: belts.sh
 #to call: belts.awk grade2.txt
 #loops through the grade2.txt file and counts how many
 #belts we have in(yellow,orange,red)
 #also count how many adults and juniors we have
 #
 #start of BEGIN
 #set FS and load the arrays and our values
 BEGIN{
     FS="#"
     #load the belt colours we are interested in only
     belt["Yellow"]
     belt["Orange"]
     belt["Red"]
     #end of BEGIN
     #load the student type
     student["Junior"]
     student["Senior"]
 }
 #loop thru array that holds the belt colours against field-1
 #if we have a match,keep a running total
 { for (colour in belt)
     {
         if ($1==colour)
             belt[colour]++
     }
 }
     #loop thru array that holds the student type against
     #field-2 if we have a match, keep a running total
        { for(senior_or_junior in student)
            {
                if($2 == senior_or_junior)
                    student[senior_or_junior]++
            }
        }
     #finished processing so print out the matches..for each array
 END{ for(colour in belt)
        print "The club has",belt[colour],colour,"Belts"

         for(senior_or_junior in student)
              print "The club has",student[senior_or_junior], senior_or_junior, "students"
    }


whwu@master:~/script> ./belts.sh color.txt
The club has 2 Orange Belts
The club has 2 Red Belts
The club has 3 Yellow Belts
The club has 7 Senior students
The club has 8 Junior students


whwu@master:~/script> cat number.txt
1
2
3
4
5
6
7
8
9
10
whwu@master:~/script> awk 'BEGIN{i=0}{i+=$1}END{print i}' number.txt
55


计算文件中单词的频率
whwu@master:~/script> cat word_freq.sh
#!/bin/bash
#word_freq.sh

if [ $# -ne 1 ];
then
echo "Usage: $0 filename";
exit -l
fi

filename=$1

egrep -o "\b[[:alpha:]]+\b" $filename | \
awk '{ count[$0]++ }
END{ printf("%-14s%s\n","Word","Count");
for (ind in count)
{ printf("%-14s%d\n",ind,count[ind]);}
}'
whwu@master:~/script> ./word_freq.sh word.txt
Word          Count
used          3
apple         3
this          1
haha          2


#! /bin/sh

tr -cs "[A-Z][a-z]" "\n" | 	 # change the complement of letter to line break and delete continuous lines
  tr "[A-Z]" "[a-z]"|            # change upper to lower
    sort |			 # sort accoeding to letters
      uniq -c |			 # delete repeated words and show the number
	sort -k1,1nr -k2 |	 # first sort according to number, large to small second sort in terms of letters
	  sed ${1:-25}q

whwu@master:~/script> cat 7.txt
1 3
3 7
4 4
7 5
23 12
1 1
2 3
5 7
whwu@master:~/script> awk 'NR%4==1{i=0;j=0; print }NR%4!=1{i+=$1;j+=$2;if(NR%4==0)print i,j}' 7.txt
1 3
14 16
23 12
8 11

whwu@master:~/script> cat test  #if循环注意格式
#!/bin/bash

#a=1;
if [ $(($1%2)) -ne 1 ];
then
        echo "ok";
else
        echo "oh~no~";
fi
whwu@master:~/script> ./test 5
oh~no~


匹配回文字（abba或aba）
whwu@master:~/script> cat match_palindrome.sh
#!/bin/bash
#match_paliindrome.sh

if [ $# -ne 2 ];
then
        echo "Usage: $0 filename string_length"
exit -l
fi

filename=$1;
basepattern='/^\(.\)'
count=$(($2/2))             #当$2=3时，count=1

for((i=1;i<$count;i++))
do
basepattern=$basepattern'\(.\)';
done

if [ $(($2%2)) -ne 0 ];       #注意if语句中的空格
then
 basepattern=$basepattern'.';
fi

for((count;count>0;count--))
do
basepattern=$basepattern'\'"$count";
done

basepattern=$basepattern'$/p'
sed -n "$basepattern" $filename
whwu@master:~/script> cat 8.txt
abba
cac
acssca
acsca
qwerrewq
wecac
acssca
tyyt
uioiu
123321
1221
121
whwu@master:~/script> ./match_palindrome.sh 8.txt 5
acsca
uioiu

whwu@master:~/script> cat match_palindrome2.sh #通过rev来判断是否是回文字
#!/bin/bash

string=$1
if [[ "$string" == "$(echo $string | rev )" ]];
then
echo "Palindrome"
else
echo "Not palindrome"
fi
whwu@master:~/script> ./match_palindrome2.sh asdsa
Palindrome

whwu@master:~/script> cat number.sh   #for(...)中不能进行小数运算 生成含小数的数列
#!/bin/bash

j=10
for ((i=1;i<=5;i++))
do
        echo $j;
        j=$(echo "$j-0.5" | bc);
done

whwu@master:~/script> ./number.sh
10
9.5
9.0
8.5
8.0

########文件内容叠加##########
whwu@master:~/script/test> cat addfile.sh
#!/bin/bash
#add several files into one file

for f in ./*.txt
do
        tr -d '\n' < $f >> big.txt
done



##############echo的小技巧#############
whwu@master:~/script> var="This is a line of text"
whwu@master:~/script> echo ${var/line/REPLACED}
This is a REPLACED of text

whwu@master:~/script> string=abcdefghijklmnopqrstuvwxyz 

whwu@master:~/script> echo ${string:4}    #echo ${var_name:start_point:length} 第四个之后
efghijklmnopqrstuvwxyz

whwu@master:~/script> echo ${string:4:3}   #第四个之后三个字母
efg

whwu@master:~/script> echo ${string:(-1)}
z

whwu@master:~/script> echo ${string:(-2)}
yz


gau2tm.sh
#!/bin/bash

ls *.gjf > gjf.list
let docnum=$(wc -l gjf.list | cut -c1-2)
gjfnum=0
let linini=0
let linend=0
let linnum=0
cp gjf.list doc.list
sed -i 's/.gjf//g' doc.list
while [ "$gjfnum" -lt "$docnum" ]
        do
        let gjfnum=gjfnum+1
	mkdir $(head -$gjfnum doc.list | tail -1)
#	mv $(head -$gjfnum gjf.list | tail -1) $(head -$gjfnum doc.list | tail -1)
#	cd $(head -$gjfnum doc.list | tail -1)

grep -n '^$' $(head -$gjfnum gjf.list | tail -1) > null-line.txt
sed -i 's/://g' null-line.txt
let linini=$(head -2 null-line.txt | tail -1)
let linend=$(head -3 null-line.txt | tail -1)
let linnum=linend-linini-2
#cat head.txt > turbo.in
echo -e "%title\nsigle point\n%method\nENRGY :: ri-mp2/def2-SVP \n%charge\n0\n%coord xyz" > turbo.in
echo $linnum >> turbo.in
echo "" >> turbo.in
let linend=linend-1
head -$linend $(head -$gjfnum gjf.list | tail -1) > coord.txt
tail -$linnum coord.txt >> turbo.in
echo "%end" >> turbo.in
rm coord.txt null-line.txt

mv turbo.in $(head -$gjfnum doc.list | tail -1)
cp pbs_tmole $(head -$gjfnum doc.list | tail -1)/pbs_tmole
done



格式转化coord到tmole
#!/bin/bash
#coord2tmole.sh--format transfer


#generate gaussion format
basename `pwd` > tmp
cat > $(head tmp).gjf << EOF   #注意EOF命令的运用
# hf/3-21g

test

0 1
EOF
grep -n 'redundant$' coord > tmp2
sed -i 's/:$redundant//g' tmp2
head -n $(cat tmp2) coord > tmp3
sed -i '1d' tmp3
sed -i '$d' tmp3
awk '{printf("\t %c %f   %f   %f \n"),$4,$1*0.529177,$2*0.529177,$3*0.529177}' tmp3 >> $(head tmp).gjf
echo '' >> $(head tmp).gjf
rm tmp*


#generate tmole format
cp *.gjf  tmp.gjf

let linini=0
let linend=0
let linnum=0

grep -n '^$' tmp.gjf > null-line.txt
sed -i 's/://g' null-line.txt
let linini=$(head -2 null-line.txt | tail -1)
let linend=$(head -3 null-line.txt | tail -1)
let linnum=linend-linini-2

sed -i '1,5d' tmp.gjf
sed -i '$d' tmp.gjf

echo -e "%title\nsigle point\n%method\nENRGY :: ri-b-lyp/TZVP \n%charge\n0\n%coord xyz" > turbo.in
echo $linnum >> turbo.in
echo -e "Energy=" >> turbo.in
cat tmp.gjf >> turbo.in
echo -e "%add_control_commands\n\$disp3\nADD END\n%end" >> turbo.in  #\$disp3 转译符



################文字解密##############
whwu@master:~/script> cat puzzle-help.sh
#!/bin/bash
#puzzle-help egrep-pattern [word-list-files]

pattern="$1"

egrep -h -i "$pattern" linux.words 2> /dev/null | sort -u -f
whwu@master:~/script> ./puzzle-help.sh '^b.....[xz]...$'  #匹配字母开头是b，5个字母后是x或z 三个字母后结束
Babelizing
bamboozled
bamboozler
bamboozles
baronizing
Bellinzona
Belshazzar
bigamizing
bilharzial
Birobizhan
botanizing
Brontozoum
Buitenzorg
bulldozers
bulldozing
