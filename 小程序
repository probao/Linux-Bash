计算1+2+...+100
#!/bin/bash
#sum1.sh

total=0;   
num=0;
while((num<=100));
do
        total=` expr $total + $num `   #expr在循环中用于增量计算,注意空格
        num=` expr $num + 1 `
done

echo "$total"


范例：有一组数据，存有某村所有家庭的人数和月总收入，找出人均月收入最高家庭
#!/bin/bash
# gettopfamily.sh

[ $# -lt 1 ] && echo "please input the income file" && exit -1
[ ! -f $1 ] && echo "$1 is not a file" && exit -1

income=$1
awk '{
        printf("%d %0.2f\n", $1, $3/$2);
}' $income | sort -k 2 -n -r


aaa 12 1 
aaa 12 2 
aaa 12 4 
aaa 15 1
aaa 15 2
bbb 12 1
bbb 12 2
最后我想得出的输出结果为
aaa  12  7
aaa  15  3
bbb  12  3

#!/usr/bin/awk -f	#表示以下语句的解释器为awk，-f 表示，awk脚本运行时需要跟一个文件名参数（awk一般就是用于文本处理的）。
NR == 1 { col1 = $1; col2 = $2; col3 = $3; }	#NR==1 行数为1 之后赋值 注意空格	
NR > 1 {        
	if($1 == col1 && $2 == col2)                
	col3+=$3;				# col3+$3=$3
else        
	{                   
	print(col1" "col2" "col3);               
	col1 = $1; col2 = $2; col3 = $3;        
	}   
}
END { print(col1" "col2" "col3); }


NR小例子
whwu@master:~/script> echo -e "A B C\nD E F\nG H I" | awk 'NR==1 {print $1}' # Number 0f Row（NR）
A


一个文件中如果有相同的行连续出现就只打印一次
whwu@master:~/script> cat error_strip.sh
#!/bin/awk -f

 #to call: error_strip.awk <filename>
 #strips out the ERROR* lines if there are more than one
 #ERROR* lines after each filed record.
 BEGIN{
     error_line=""                                       #定义变量error_line
 }
     #tell awk the whole is "ERROR *"
     {
         if ($0 == "ERROR*" && error_line == "ERROR*")   #如果整行是ERROR*，且error_line=ERROR*
            { next}					 #回到程序开头，忽略后面语句
        else
            { error_line = $0;                           #else error_line为整行信息
        print                                            #打印
        }
     }


 #!/bin/awk -f
 #error_strip.awk
 #to call: error_strip.awk <filename>
 #strips out the ERROR* lines if there are more than one
 #ERROR* lines after each filed record.
 BEGIN{
     error_line=""
 }
     #tell awk the whole is "ERROR *"
     {
         if ($0 == "ERROR*" && error_line == "ERROR*")
             next;
         error_line = $0;
         print
     }

whwu@master:~/script>cat error_strip.sh
INVALID LCSD 98GJ23
ERROR*
ERROR*
CAUTION LPSS ERROR ON ACC NO.
ERROR*
ERROR*
ERROR*
ERROR*
ERROR*
PASS FILED INVALID ON GHSI
ERROR*
CUTION LPSS ERROR ON ACC NO.
ERROR*
ERROR*

whwu@master:~/script> ./error_strip.sh error.txt
LID LCSD 98GJ23
ERROR*
CAUTION LPSS ERROR ON ACC NO.
ERROR*
PASS FILED INVALID ON GHSI
ERROR*
CUTION LPSS ERROR ON ACC NO.
ERROR*


#向AWK脚本传递参数
whwu@master:~/script> cat age.sh
#!/bin/awk -f
#age.sh
{
        if($5 < AGE )
                print $0
}
whwu@master:~/script> ./age.sh AGE=10 grade.txt
M.Tansley       05/99   48311   Green   8       40      44
J.Lulu          06/99   48317   green   9       24      26

awk 数组，awk数组是类似于一个键值对，既可以使用数字做下标，也可以使用字符串做下标
whwu@master:~/script> cat arraytest.sh
#!/bin/awk -f
#name:arraytest.sh
#prints out an array

BEGIN{
        record="123#456#789";
        split(record,myarray,"#")
}
END{
        for(i in myarray)
        {
                print myarray[i]
        }
}
whwu@master:~/script> ./arraytest.sh size.txt
123
456
789


grade_student.txt:
 
Yellow#Junior
Orange#Senior
Yellow#Junior
Purple#Junior
Brown-2#Junior
White#Senior
Orange#Senior
Red#Junior
Brown-2#Senior
Yellow#Senior
Red#Junior
Blue#Senior
Green#Senior
Purple#Junior
White#Junior

 #!/bin/awk -f
 #name: belts.sh
 #to call: belts.awk grade2.txt
 #loops through the grade2.txt file and counts how many
 #belts we have in(yellow,orange,red)
 #also count how many adults and juniors we have
 #
 #start of BEGIN
 #set FS and load the arrays and our values
 BEGIN{
     FS="#"
     #load the belt colours we are interested in only
     belt["Yellow"]
     belt["Orange"]
     belt["Red"]
     #end of BEGIN
     #load the student type
     student["Junior"]
     student["Senior"]
 }
 #loop thru array that holds the belt colours against field-1
 #if we have a match,keep a running total
 { for (colour in belt)
     {
         if ($1==colour)
             belt[colour]++
     }
 }
     #loop thru array that holds the student type against
     #field-2 if we have a match, keep a running total
        { for(senior_or_junior in student)
            {
                if($2 == senior_or_junior)
                    student[senior_or_junior]++
            }
        }
     #finished processing so print out the matches..for each array
 END{ for(colour in belt)
        print "The club has",belt[colour],colour,"Belts"

         for(senior_or_junior in student)
              print "The club has",student[senior_or_junior], senior_or_junior, "students"
    }


whwu@master:~/script> ./belts.sh color.txt
The club has 2 Orange Belts
The club has 2 Red Belts
The club has 3 Yellow Belts
The club has 7 Senior students
The club has 8 Junior students




